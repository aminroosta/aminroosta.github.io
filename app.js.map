{"version":3,"sources":["../library/src/core/data-source.ts","../library/src/core/data-view.ts","../library/src/input/user-input.ts","../library/src/draw/candle/candle-border.ts","../library/src/draw/candle/candle-wick.ts","../library/src/draw/candle/candle-body.ts","../library/src/draw/candle/candle.ts","../library/src/core/build-regl.ts","../library/src/theme/convert-color.ts","../library/src/theme/default-themes.ts","../library/src/theme/build-theme.ts","../library/src/index.ts","src/index.tsx"],"names":["MUTATING_ARR_FNS","BAR_SIZE","data","bar","Float32Array","bar2x_cpu","bar2x","bar3x_cpu","bar3x","ids_cpu","ids","is_dirty","regl","length","N","Math","max","i","buffer","epoch","open","high","low","close","volume","set","refresh","buffers","Proxy","get","target","key","receiver","includes","Reflect","idx","value","MIN_VISIBLE_BARS","clamp","v","min","width","getBarCount","DPR","window","devicePixelRatio","zoom","origin","delta","move","bars","bar_count","pixels","squeeze","setWidth","getZoom","getOrigin","view","element","e","preventDefault","deltaY","deltaX","event","callback","ArrowLeft","ArrowRight","removeEventListener","wheel","keydown","one","two","t","touches","x","pageX","y","pageY","addEventListener","passive","tstart","tmove","onDestroy","count","_","instances","primitive","depth","enable","attributes","inst_id","stride","divisor","vert_id","offset","ohlc","uniforms","posColor","theme","negColor","resolution","ctx","viewportWidth","viewportHeight","y_min_max","x_zoom","x_origin","vert","frag","wick","candle_wick_1","body","candle_body_1","border","candle_border_1","source","hollow","onResize","pixelRatio","canvas","document","createElement","Object","assign","style","margin","padding","top","left","display","imageRendering","appendChild","position","w","innerWidth","h","innerHeight","bounds","getBoundingClientRect","height","resizeObserver","ResizeObserver","setTimeout","resize","observe","disconnect","removeChild","gl","getContext","antialias","regl_1d","extensions","cvs","cache","color","fillStyle","fillRect","getImageData","map","candle","backup","rgba","merge","clone","rgba_colors","setTheme","default_themes_1","getRGBA","getTheme","obj","k","endsWith","convert_color_1","JSON","parse","stringify","data_source_1","data_view_1","build_regl_1","input","user_input_1","build_theme_1","candle_1","frame","ref","react_1","current","chart","index_1","push","GChart","react_dom_1","App","getElementById"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAWMA,oBACJ,OACA,QACA,UACA,WACA,SACA,QACA,UACA;MAEIC,WAAW;AAIV;MACDC;MAIAC,UAAUC,aAAaH,WACzBI,WACAC,OACAC,WACAC;MAEEC,SACFC;MAEEC,WAAW;EAKf,iBAAiBC;IACfP,gBAAgBD,aAAa,IAAIF,KAAKW,SAASZ;IAC/CM,gBAAgBH,aAAa,IAAIF,KAAKW,SAASZ;QAG3Ca,IAAIC,KAAKC,IAAIP,WAAWA,QAAQI,UAAU,KAAK;SAC9CJ,WAAWA,QAAQI,SAASC;MAC/BL,cAAcL,aAAaU,IAAI;eACtBG,IAAI,GAAGA,IAAIH,IAAI,KAAKG,GAAGR,QAAQQ,KAAKA;MAC7CP,MAAOA,OAAOA,IAAID,YAAaG,KAAKM,OAAOT;;aAGpCQ,IAAI,GAAGA,IAAIf,KAAKW,UAAUI;MACjCd,IAAI,KAAKD,KAAKe,GAAGE;MACjBhB,IAAI,KAAKD,KAAKe,GAAGG;MACjBjB,IAAI,KAAKD,KAAKe,GAAGI;MACjBlB,IAAI,KAAKD,KAAKe,GAAGK;MACjBnB,IAAI,KAAKD,KAAKe,GAAGM;MACjBpB,IAAI,KAAKD,KAAKe,GAAGO;MAEjBnB,UAAUoB,IAAItB,MAAM,IAAIc,IAAI,KAAKhB;MACjCI,UAAUoB,IAAItB,MAAM,IAAIc,IAAI,KAAKhB;MAEjCM,UAAUkB,IAAItB,MAAM,IAAIc,IAAI,KAAKhB;MACjCM,UAAUkB,IAAItB,MAAM,IAAIc,IAAI,KAAKhB;MACjCM,UAAUkB,IAAItB,MAAM,IAAIc,IAAI,KAAKhB;;IAEnCK,QAASA,SAASA,MAAMD,cAAeO,KAAKM,OAAOb;IACnDG,QAASA,SAASA,MAAMH,cAAeO,KAAKM,OAAOX;;EAGrD,iBAAiBK;QACXD;MACFe,QAAQd;MACRD,WAAW;;;MAEJD;MAAKJ;MAAOE;MAAOH;MAAWE;;;EAEzCL,KAAKyB,UAAUA;aAEJC,MAAM1B;IACf2B,IAAIC,QAAQC,KAAKC;WACVrB,YAAYX,iBAAiBiC,SAASF;QACzCpB,WAAW;;aAENuB,QAAQL,IAAIC,QAAQC,KAAKC;;IAElCP,IAAIK,QAAQK,KAAKC,OAAOJ;iBACXG,QAAQ;QACjBxB,WAAW;;aAENuB,QAAQT,IAAIK,QAAQK,KAAKC,OAAOJ;;;;;;;;;;MC/FvCK,mBAAmB;MACnBC,QAAQ,CAACC,GAAWC,KAAaxB;SAC9BuB,IAAIC,MAAMA,MAAMD,IAAIvB,MAAMA,MAAMuB;;AAKlC,uBACLE,OACAC;QAEMC,MAAMC,OAAOC;MAIfC,OAAO/B,KAAKC,IAAI,IAAI2B,MAAMD,gBAAgB,MAAMD;MAChDM,SAASL,gBAAgBD,QAAQK,OAAO;EAe5C,kBAAkBV;UACVY,SAASP,QAAQL,SAASU;IAChCL,QAAQL;IACRa,KAAKD;;EAEP,cAAcE;UACNC,YAAYV,QAAQK;IAC1BC,SAAST,MACPS,SAASG,MACTb,mBAAmBc,WACnBT,gBAAgBL;;EAGpB,iBAAiBe;UACTJ,QAAQI,SAASN;UACjBK,YAAYV,QAAQK;IAC1BA,OAAOR,MAAMG,SAASU,YAAYH,QAAQL,KAAK,KAAKA;UAC9CO,OAAOT,QAAQK,OAAOK;IAC5BF,MAAMC;;;IAIND;IACAI;IACAC;IACAC,SAAS,MAAMT;IACfU,WAAW,MAAMT;;;;;;;;;ACvDd,wBACLU,MACAC;EAEA,eAAeC;IACbA,EAAEC;IACFH,KAAKJ,QAAQM,EAAEE;IACfJ,KAAKR,KAAKU,EAAEG,SAASL,KAAKF;;EAG5B,iBAAiBQ;UAETC;MACJC,WAAW,MAAMR,KAAKR,MAAM;MAC5BiB,YAAY,MAAMT,KAAKR,MAAM;OAC7Bc,MAAMhC;IACRiC,YAAYA;;EAGd;IACEN,QAAQS,oBAAoB,SAASC;IACrCxB,OAAOuB,oBAAoB,WAAWE;;MAIpCC,KACFC;EAEF,gBAAgBZ;IACdA,EAAEC;UACIY,IAAIb,EAAEc;IACZH;MAAQI,GAAGF,EAAE,GAAGG;MAAOC,GAAGJ,EAAE,GAAGK;;QAC3BL,EAAE;MACJD;QAAQG,GAAGF,EAAE,GAAGG;QAAOC,GAAGJ,EAAE,GAAGK;;;;EAKnC,eAAelB;IACbA,EAAEC;QACED,EAAEc,QAAQ5D,WAAW;YACjBiD,SAASQ,IAAII,IAAIf,EAAEc,QAAQ,GAAGE;MAGpClB,KAAKR,KAAKa,SAASL,KAAKF;;;EAK5BG,QAAQoB,iBAAiB,SAASV;IAASW,SAAS;;EACpDnC,OAAOkC,iBAAiB,WAAWT;EACnCX,QAAQoB,iBAAiB,cAAcE,QAAQ;EAC/CtB,QAAQoB,iBAAiB,aAAaG,OAAO;;IAG3CC;;;;;;;;;;;EC5BFC,OAAO,CAACC,IAAKD,WAAYA,QAAQ;EACjCE,WAAW;EACXC,WAAW;EACXC;IAASC,QAAQ;;EACjBC;IACEC,SAAS,CAACN,IAAK1E;MACbQ,QAAQR;MACRiF,QAAQ;MACRC,SAAS;;IAEXC,SAAS,CAACT,IAAK1E;MACbQ,QAAQR;MACRoF,QAAQ;MACRH,QAAQ;MACRC,SAAS;;IAEXG,MAAM,CAACX,IAAK9E;MACVY,QAAQZ;MACRwF,QAAQ;MACRH,QAAQ,IAAI;;;EAGhBK;IACEC,UAAU,CAACb,IAAKc,WAAYA,MAAMD;IAClCE,UAAU,CAACf,IAAKc,WAAYA,MAAMC;IAClCC,YAAY,AAACC,QAASA,IAAIC,eAAeD,IAAIE;IAC7CC,WAAW,CAACpB,IAAKoB,eAAgBA;IACjCC,QAAQ,CAACrB,IAAKqB,YAAaA;IAC3BC,UAAU,CAACtB,IAAKsB,cAAeA;;EAEjCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA4CAC;;;;;;;;;;;;;;EC1EAzB,OAAO,CAACC,IAAKD,WAAYA,QAAQ;EACjCE,WAAW;EACXC,WAAW;EACXC;IAASC,QAAQ;;EACjBC;IACEC,SAAS,CAACN,IAAK1E;MACbQ,QAAQR;MACRiF,QAAQ;MACRC,SAAS;;IAEXC,SAAS,CAACT,IAAK1E;MACbQ,QAAQR;MACRiF,QAAQ;MACRC,SAAS;;IAEXG,MAAM,CAACX,IAAK9E;MACVY,QAAQZ;MACRwF,QAAQ;MACRH,QAAQ,IAAI;;;EAGhBK;IACEC,UAAU,CAACb,IAAKc,WAAYA,MAAMD;IAClCE,UAAU,CAACf,IAAKc,WAAYA,MAAMC;IAClCC,YAAY,AAACC,QAASA,IAAIC,eAAeD,IAAIE;IAC7CC,WAAW,CAACpB,IAAKoB,eAAgBA;IACjCC,QAAQ,CAACrB,IAAKqB,YAAaA;IAC3BC,UAAU,CAACtB,IAAKsB,cAAeA;;EAEjCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAmCAC;;;;;;;;;;;;;;EChEAzB,OAAO,CAACC,IAAKD,WAAYA,QAAQ;EACjCE,WAAW;EACXC,WAAW;EACXC;IAASC,QAAQ;;EACjBC;IACEC,SAAS,CAACN,IAAK1E;MACbQ,QAAQR;MACRiF,QAAQ;MACRC,SAAS;;IAEXC,SAAS,CAACT,IAAK1E;MACbQ,QAAQR;MACRoF,QAAQ;MACRH,QAAQ;MACRC,SAAS;;IAEXG,MAAM,CAACX,IAAK5E;MACVU,QAAQV;MACRsF,QAAQ;MACRH,QAAQ,IAAI;;;EAGhBK;IACEC,UAAU,CAACb,IAAKc,WAAYA,MAAMD;IAClCE,UAAU,CAACf,IAAKc,WAAYA,MAAMC;IAClCC,YAAY,AAACC,QAASA,IAAIC,eAAeD,IAAIE;IAC7CC,WAAW,CAACpB,IAAKoB,eAAgBA;IACjCC,QAAQ,CAACrB,IAAKqB,YAAaA;IAC3BC,UAAU,CAACtB,IAAKsB,cAAeA;;EAEjCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAsCAC;;;;;;;;;;;;;;;;AC1FK,qBAAqBhG;QACpBiG,OAAOjG,KAAKkG;QACZC,OAAOnG,KAAKoG;QACZC,SAASrG,KAAKsG;SAEb,UACLC,QACA1D,MAKAyC;WAEQ5F,OAAOE,OAAOE,OAAQyG,OAAOxF,QAAQf;IAC7CiG;MACIX,OAAOA,MAAMW;MAAMvG;MAAOI;MAAKyE,OAAOgC,OAAOtG;SAAW4C;;SAEvDyC,MAAMkB;MACTL;QAAOb,OAAOA,MAAMa;QAAMvG;QAAOE;QAAKyE,OAAOgC,OAAOtG;WAAW4C;;;IAEjEwD;MAASf,OAAOA,MAAMe;MAAQ3G;MAAOI;MAAKyE,OAAOgC,OAAOtG;SAAW4C;;;;;;;;;;;;;AC1BhE,mBACLC,SACA2D;QAEMC,oBACI1E,WAAW,cAAc,IAAIA,OAAOC;QACxC0E,SAASC,SAASC,cAAc;EACtCC,OAAOC,OAAOJ,OAAOK;IACnBX,QAAQ;IACRY,QAAQ;IACRC,SAAS;IACTC,KAAK;IACLC,MAAM;IACNC,SAAS;IACTC,gBAAgB;;EAElBxE,QAAQyE,YAAYZ;MAEhB7D,YAAY8D,SAAST;IACvBQ,OAAOK,MAAMQ,WAAW;IACxBV,OAAOC,OAAOjE,QAAQkE;MACpBC,QAAQ;MACRC,SAAS;;;EAIb;QACMO,IAAIzF,OAAO0F;QACXC,IAAI3F,OAAO4F;QACX9E,YAAY8D,SAAST;UACnB0B,SAAS/E,QAAQgF;MACrBL,IAAII,OAAOhG;MACX8F,IAAIE,OAAOE;;IAEbpB,OAAO9E,QAAQ6E,aAAae;IAC5Bd,OAAOoB,SAASrB,aAAaiB;IAC7Bb,OAAOC,OAAOJ,OAAOK;MACnBnF,OAAO4F,IAAI;MACXM,QAAQJ,IAAI;;IAEdlB,YAAYA,SAASC,aAAae,GAAGf,aAAaiB;;MAGhDK;MAEAlF,YAAY8D,SAAST,eAAe8B,mBAAmB;IAEzDD,qBAAqBC,eAAe;MAClCC,WAAWC;;IAEbH,eAAeI,QAAQtF;;IAEvBd,OAAOkC,iBAAiB,UAAUiE,QAAQ;;EAI5C;QACMH;MACFA,eAAeK;;MAEfrG,OAAOuB,oBAAoB,UAAU4E;;IAEvCrF,QAAQwF,YAAY3B;;EAGtBwB;QAEMI,KAAK5B,OAAO6B,WAAW;IAC3BC,WAAW;;SAGNC;IACLH,IAAIA;IACJI,aACE,0BACA;;;;;;;;;;mBC3EkB;QAChBC,MAAMhC,SAASC,cAAc;EACnC+B,IAAIb,SAAS;EACba,IAAI/G,QAAQ;QACN4D,MAAMmD,IAAIJ,WAAW;QAErBK;SAEC,UACLC;QAEID,MAAMC;aACDD,MAAMC;;SAEVA;cAEK,GAAG,GAAG,GAAG;;IAEnBrD,IAAIsD,YAAYD;IAChBrD,IAAIuD,SAAS,GAAG,GAAG,GAAG;UAChB1J,OAAOmG,IAAIwD,aAAa,GAAG,GAAG,GAAG,GAAG3J;WACnCuJ,MAAMC,aAAaxJ,MAAM4J,IAAI,AAACvH,KAAMA,IAAI;;;;;;;;;;ECpBjDwH;IACE3C,QAAQ;IACRH;MACEhB,UAAU;MACVE,UAAU;;IAEZY;MACEd,UAAU;MACVE,UAAU;;IAEZU;MACEZ,UAAU;MACVE,UAAU;;;;;EAMd4D;IACE3C,QAAQ;IACRH;MACEhB,UAAU;MACVE,UAAU;;IAEZY;MACEd,UAAU;MACVE,UAAU;;IAEZU;MACEZ,UAAU;MACVE,UAAU;;;;;;;;;;;;ACZT;MACD6D;MAEAC;EAEJ,kBAAkB/D;IAChBgE,MAAMF,QAAQ9D;IACd+D,OAAOE,MAAMH;IACbI,YAAYH;;EAIdI,SAASC;;IAGPC,SAAS,MAAMN;IACfO,UAAU,MAAMR;IAChBK;;;;AAIJ,qBAAqBI;WACVC,KAAKD;eACDA,IAAIC,MAAM,YAAYD,IAAIC,OAAO;MAC1CN,YAAYK,IAAIC;eACPA,EAAEC,SAAS;MACpBF,IAAIC,KAAKE,wBAAQH,IAAIC;;;;AAI3B,eACE5I,QACAqF;WAESuD,KAAKvD;eAEHA,OAAOuD,MAAM,YAAYvD,OAAOuD;MAEvC5I,OAAO4I,KAAK5I,OAAO4I;MACnBR,MAAMpI,OAAO4I,IAAIvD,OAAOuD;;MAExB5I,OAAO4I,KAAKvD,OAAOuD;;;;MAKnBP,QAAQ,AAACM,OAAaI,KAAKC,MAAMD,KAAKE,UAAUN;;;;;;;;;;;;;AC1D/C,qBAAsB/G;QAGrByD,SAAS6D;QACTvH,OAAOwH,0BACX,KACA,MAAM9D,OAAOtG;QAETD,OAAOsK,uBACXxH,SACA,CAAC2E,GAAGjD,MAAM3B,KAAKH,SAAS+E;QAEpB8C,QAAQC,4BAAe3H,MAAMC;QAC7BwC,QAAQmF;QACRtB,SAASuB,qBAAY1K;EAE3BA,KAAK2K,MAAM;UACHtB,OAAO/D,MAAMqE;IACnBR,OAAO5C;MACLT,UAAUjD,KAAKD;MACfiD,QAAQhD,KAAKF;MACbiD,YAAY,GAAG;OACdyD,KAAKF;;;IAIR5C,QAAQA;IACR1D;IACAyC;;;;;;;;;;;;;;;AChCJ;QACQsF,MAAMC;EACZA,kBAAU;UACF/H,UAAU8H,IAAIE;UACdC,QAAQC;MAAalI;;IAG3BiI,MAAMxE,OAAO0E;MAET1K,OAAO;MAAGC,MAAM;MAAGC,MAAM;MAAGC,KAAK;MAAGC,OAAO;MAAGC,QAAQ;;MACtDL,OAAO;MAAGC,MAAM;MAAGC,MAAM;MAAIC,KAAK;MAAGC,OAAO;MAAGC,QAAQ;;MACvDL,OAAO;MAAGC,MAAM;MAAGC,MAAM;MAAGC,KAAK;MAAGC,OAAO;MAAGC,QAAQ;;MACtDL,OAAO;MAAGC,MAAM;MAAGC,MAAM;MAAIC,KAAK;MAAGC,OAAO;MAAGC,QAAQ;;MACvDL,OAAO;MAAGC,MAAM;MAAGC,MAAM;MAAGC,KAAK;MAAGC,OAAO;MAAGC,QAAQ;;MACtDL,OAAO;MAAGC,MAAM;MAAGC,MAAM;MAAIC,KAAK;MAAGC,OAAO;MAAGC,QAAQ;;MACvDL,OAAO;MAAGC,MAAM;MAAGC,MAAM;MAAGC,KAAK;MAAGC,OAAO;MAAGC,QAAQ;;MACtDL,OAAO;MAAGC,MAAM;MAAGC,MAAM;MAAIC,KAAK;MAAGC,OAAO;MAAGC,QAAQ;;IAI3DoB,OAAO+I,QAAQA;;;QAGF;;MACbhD,QAAQ;;SACF6C;;;AAGV;qKAGKM;;AAILC,kDAAQC,YAAQxE,SAASyE,eAAe","file":"","sourcesContent":["import { Buffer, Regl } from \"regl\";\n\nexport type DataSource = ReturnType<typeof buildDataSource>;\nexport type Bar = {\n  epoch: number;\n  open: number;\n  high: number;\n  low: number;\n  close: number;\n  volume: number;\n};\nconst MUTATING_ARR_FNS = [\n  \"pop\",\n  \"push\",\n  \"concat\",\n  \"reverse\",\n  \"shift\",\n  \"sort\",\n  \"splice\",\n  \"unshift\",\n];\nconst BAR_SIZE = 6;\n\n// returns an augmented Bar[] to hold data, just like a normal array.\n// but it tracks changes internally via a Proxy object.\nexport function buildDataSource() {\n  let data: Bar[] & {\n    buffers: typeof buffers;\n  } = [] as any;\n\n  let bar = new Float32Array(BAR_SIZE),\n    bar2x_cpu: Float32Array,\n    bar2x: Buffer,\n    bar3x_cpu: Float32Array,\n    bar3x: Buffer;\n\n  let ids_cpu: Float32Array,\n    ids: Buffer;\n\n  let is_dirty = true;\n\n  // refresh the gpu buffers,\n  // bar2x holds 2 consecutive copies of the data, while bar3x holds 3 copies.\n  // these extra copies are required to render lines and triangles.\n  function refresh(regl: Regl) {\n    bar2x_cpu = new Float32Array(2 * data.length * BAR_SIZE);\n    bar3x_cpu = new Float32Array(3 * data.length * BAR_SIZE);\n\n    // ids buffer is used as instance/vertex id.\n    let N = Math.max(ids_cpu && ids_cpu.length || 100, 100);\n    if (!ids_cpu || ids_cpu.length < N) {\n      ids_cpu = new Float32Array(N * 2);\n      for (let i = 0; i < N * 2; ++i) ids_cpu[i] = i;\n      ids = (ids && ids(ids_cpu)) || regl.buffer(ids_cpu);\n    }\n\n    for (let i = 0; i < data.length; ++i) {\n      bar[0] = data[i].epoch;\n      bar[1] = data[i].open;\n      bar[2] = data[i].high;\n      bar[3] = data[i].low;\n      bar[4] = data[i].close;\n      bar[5] = data[i].volume;\n\n      bar2x_cpu.set(bar, (2 * i + 0) * BAR_SIZE);\n      bar2x_cpu.set(bar, (2 * i + 1) * BAR_SIZE);\n\n      bar3x_cpu.set(bar, (3 * i + 0) * BAR_SIZE);\n      bar3x_cpu.set(bar, (3 * i + 1) * BAR_SIZE);\n      bar3x_cpu.set(bar, (3 * i + 2) * BAR_SIZE);\n    }\n    bar2x = (bar2x && bar2x(bar2x_cpu)) || regl.buffer(bar2x_cpu);\n    bar3x = (bar3x && bar3x(bar2x_cpu)) || regl.buffer(bar3x_cpu);\n  }\n\n  function buffers(regl: Regl) {\n    if (is_dirty) {\n      refresh(regl);\n      is_dirty = false;\n    }\n    return { ids, bar2x, bar3x, bar2x_cpu, bar3x_cpu };\n  }\n  data.buffers = buffers;\n\n  return new Proxy(data, {\n    get(target, key, receiver) {\n      if (!is_dirty && MUTATING_ARR_FNS.includes(key as string)) {\n        is_dirty = true;\n      }\n      return Reflect.get(target, key, receiver);\n    },\n    set(target, idx, value, receiver) {\n      if (typeof idx === \"number\") {\n        is_dirty = true;\n      }\n      return Reflect.set(target, idx, value, receiver);\n    },\n  });\n}\n","const MIN_VISIBLE_BARS = 5;\nconst clamp = (v: number, min: number, max: number) => {\n  return v < min ? min : v > max ? max : v;\n};\n\nexport type DataView = ReturnType<typeof buildDataView>;\n\nexport function buildDataView(\n  width: number,\n  getBarCount: () => number,\n) {\n  const DPR = window.devicePixelRatio;\n\n  // show as many bars as possible, but leave\n  // an empty space (i.e 10 bars) to the right.\n  let zoom = Math.max(7 * DPR, (getBarCount() + 10) / width);\n  let origin = getBarCount() - width / zoom + 10;\n\n  // imagine shrinking the following chart,\n  // |    *       |\n  // |  *****     |\n  // |********    |\n  // we move them to left if there are enough columns.\n  // |*       |\n  // |***     |\n  // |****    |\n  // otherwise we keep them in place.\n  // |*    |\n  // |***  |\n  // |**** |\n  // same logic applies when we are expanding the chart.\n  function setWidth(value: number) {\n    const delta = (width - value) / zoom;\n    width = value;\n    move(delta);\n  }\n  function move(bars: number) {\n    const bar_count = width / zoom;\n    origin = clamp(\n      origin + bars,\n      MIN_VISIBLE_BARS - bar_count,\n      getBarCount() - MIN_VISIBLE_BARS,\n    );\n  }\n  function squeeze(pixels: number) {\n    const delta = pixels / zoom;\n    const bar_count = width / zoom;\n    zoom = clamp(width / (bar_count + delta), DPR, 45 * DPR);\n    const bars = width / zoom - bar_count;\n    move(-bars);\n  }\n\n  return {\n    move,\n    squeeze,\n    setWidth,\n    getZoom: () => zoom,\n    getOrigin: () => origin,\n  };\n}\n","import { DataView } from \"../core/data-view\";\n\nexport function trackUserInput(\n  view: DataView,\n  element: HTMLDivElement,\n) {\n  function wheel(e: WheelEvent) {\n    e.preventDefault();\n    view.squeeze(e.deltaY);\n    view.move(e.deltaX / view.getZoom());\n  }\n  // TODO: support alt + arrow\n  function keydown(event: KeyboardEvent) {\n    // @ts-ignore\n    const callback = {\n      ArrowLeft: () => view.move(-1),\n      ArrowRight: () => view.move(+1),\n    }[event.key];\n    callback && callback();\n  }\n\n  function onDestroy() {\n    element.removeEventListener(\"wheel\", wheel);\n    window.removeEventListener(\"keydown\", keydown);\n  }\n\n  // one and two finger touch last state\n  let one: { x: number; y: number },\n    two: { x: number; y: number };\n\n  function tstart(e: TouchEvent) {\n    e.preventDefault();\n    const t = e.touches;\n    one = { x: t[0].pageX, y: t[0].pageY };\n    if (t[1]) {\n      two = { x: t[1].pageX, y: t[1].pageY };\n    }\n  }\n  // TODO: handle pinch zoom\n  // TODO: add snap scroll\n  function tmove(e: TouchEvent) {\n    e.preventDefault();\n    if (e.touches.length === 1) {\n      const deltaX = one.x - e.touches[0].pageX;\n      // const deltaY = e.touches[0].pageY - one.y;\n      // view.squeeze(deltaY);\n      view.move(deltaX / view.getZoom());\n    }\n  }\n\n  // register events\n  element.addEventListener(\"wheel\", wheel, { passive: false });\n  window.addEventListener(\"keydown\", keydown);\n  element.addEventListener(\"touchstart\", tstart, false);\n  element.addEventListener(\"touchmove\", tmove, false);\n\n  return {\n    onDestroy,\n  };\n}\n","import { AttributeConfig, Buffer, DrawConfig } from \"regl\";\n\nexport const Border: DrawConfig<\n  {\n    posColor: [number, number, number, number];\n    negColor: [number, number, number, number];\n    resolution: [number, number];\n    y_min_max: [number, number];\n    x_zoom: number;\n    x_origin: number;\n  },\n  {\n    inst_id: AttributeConfig;\n    vert_id: AttributeConfig;\n    ohlc: AttributeConfig;\n  },\n  {\n    count: number;\n    x_zoom: number;\n    x_origin: number;\n    y_min_max: [number, number];\n    bar2x: Buffer;\n    ids: Buffer;\n    theme: {\n      posColor: [number, number, number, number];\n      negColor: [number, number, number, number];\n    };\n  }\n> = {\n  count: (_, { count }) => count * 2,\n  instances: 4,\n  primitive: \"lines\",\n  depth: { enable: false },\n  attributes: {\n    inst_id: (_, { ids }) => ({\n      buffer: ids,\n      stride: 4,\n      divisor: 1,\n    }),\n    vert_id: (_, { ids }) => ({\n      buffer: ids,\n      offset: 0,\n      stride: 4,\n      divisor: 0,\n    }),\n    ohlc: (_, { bar2x }) => ({\n      buffer: bar2x,\n      offset: 4,\n      stride: 6 * 4,\n    }),\n  },\n  uniforms: {\n    posColor: (_, { theme }) => theme.posColor,\n    negColor: (_, { theme }) => theme.negColor,\n    resolution: (ctx) => [ctx.viewportWidth, ctx.viewportHeight],\n    y_min_max: (_, { y_min_max }) => y_min_max,\n    x_zoom: (_, { x_zoom }) => x_zoom,\n    x_origin: (_, { x_origin }) => x_origin,\n  },\n  vert: `\n    precision mediump float;\n\n    uniform vec4 posColor;\n    uniform vec4 negColor;\n\n    uniform vec2 resolution;\n    uniform vec2 y_min_max;\n    uniform float x_zoom;\n    uniform float x_origin;\n\n    attribute float inst_id;\n    attribute float vert_id;\n    attribute vec4 ohlc;\n\n    varying vec4 color;\n\n    void main() {\n      color = ohlc[0] <= ohlc[3] ? posColor : negColor;\n\n      int vid = int(mod(vert_id, 2.0));\n      int iid = int(mod(inst_id, 4.0));\n\n      float y =\n        iid == 0 ? ohlc[0]:\n        iid == 2 ? ohlc[3]:\n        vid == 0 ? ohlc[0]:\n                   ohlc[3];\n      y = floor(\n        resolution.y * (y - y_min_max[0]) / (y_min_max[1] - y_min_max[0])\n      );\n\n      float halved = x_zoom >= 3.0 ? floor((x_zoom - 2.0) / 3.0) + 1.0 : 0.0;\n\n      float x = floor(\n        (floor(vert_id / 2.0) - x_origin + 0.5) * x_zoom + 0.5\n      );\n      x +=\n        iid == 3 ? -halved:\n        iid == 1 ? +halved:\n        vid == 0 ? -halved - 1.0:\n                   +halved;\n      gl_Position = vec4(2.0 * vec2(x, y) / resolution - 1.0, 0., 1.);\n    }`,\n  frag: `\n    precision mediump float;\n    varying vec4 color;\n    void main() {\n      gl_FragColor = color;\n    }`,\n};\n","import { AttributeConfig, Buffer, DrawConfig } from \"regl\";\n\nexport const Wick: DrawConfig<\n  {\n    posColor: [number, number, number, number];\n    negColor: [number, number, number, number];\n    resolution: [number, number];\n    y_min_max: [number, number];\n    x_zoom: number;\n    x_origin: number;\n  },\n  {\n    inst_id: AttributeConfig;\n    vert_id: AttributeConfig;\n    ohlc: AttributeConfig;\n  },\n  {\n    count: number;\n    x_zoom: number;\n    x_origin: number;\n    y_min_max: [number, number];\n    bar2x: Buffer;\n    ids: Buffer;\n    theme: {\n      posColor: [number, number, number, number];\n      negColor: [number, number, number, number];\n    };\n  }\n> = {\n  count: (_, { count }) => count * 2,\n  instances: 2,\n  primitive: \"lines\",\n  depth: { enable: false },\n  attributes: {\n    inst_id: (_, { ids }) => ({\n      buffer: ids,\n      stride: 4,\n      divisor: 1,\n    }),\n    vert_id: (_, { ids }) => ({\n      buffer: ids,\n      stride: 4,\n      divisor: 0,\n    }),\n    ohlc: (_, { bar2x }) => ({\n      buffer: bar2x,\n      offset: 4,\n      stride: 6 * 4,\n    }),\n  },\n  uniforms: {\n    posColor: (_, { theme }) => theme.posColor,\n    negColor: (_, { theme }) => theme.negColor,\n    resolution: (ctx) => [ctx.viewportWidth, ctx.viewportHeight],\n    y_min_max: (_, { y_min_max }) => y_min_max,\n    x_zoom: (_, { x_zoom }) => x_zoom,\n    x_origin: (_, { x_origin }) => x_origin,\n  },\n  vert: `\n    precision mediump float;\n\n    uniform vec4 posColor;\n    uniform vec4 negColor;\n\n    uniform vec2 resolution;\n    uniform vec2 y_min_max;\n    uniform float x_zoom;\n    uniform float x_origin;\n\n    attribute float inst_id;\n    attribute float vert_id;\n    attribute vec4 ohlc;\n\n    varying vec4 color;\n\n    void main() {\n      color = ohlc[0] <= ohlc[3] ? posColor : negColor;\n      int mode = int(mod(vert_id, 2.0) + 2.0 * inst_id);\n\n      float y = \n        mode == 0 ? ohlc[1] :\n        mode == 1 ? max(ohlc[0], ohlc[3]):\n        mode == 2 ? ohlc[2] :\n                    min(ohlc[0], ohlc[3]);\n      y = floor(\n        resolution.y * (y - y_min_max[0]) / (y_min_max[1] - y_min_max[0])\n      );\n\n      float x = floor(\n        (floor(vert_id / 2.0) - x_origin + 0.5) * x_zoom + 0.5\n      );\n      gl_Position = vec4(2.0 * vec2(x, y) / resolution - 1.0, 0., 1.);\n    }`,\n  frag: `\n    precision mediump float;\n    varying vec4 color;\n    void main() {\n      gl_FragColor = color;\n    }`,\n};\n","import { AttributeConfig, Buffer, DrawConfig } from \"regl\";\n\nexport const Body: DrawConfig<\n  {\n    posColor: [number, number, number, number];\n    negColor: [number, number, number, number];\n    resolution: [number, number];\n    y_min_max: [number, number];\n    x_zoom: number;\n    x_origin: number;\n  },\n  {\n    inst_id: AttributeConfig;\n    vert_id: AttributeConfig;\n    ohlc: AttributeConfig;\n  },\n  {\n    count: number;\n    x_zoom: number;\n    x_origin: number;\n    y_min_max: [number, number];\n    bar3x: Buffer;\n    ids: Buffer;\n    theme: {\n      posColor: [number, number, number, number];\n      negColor: [number, number, number, number];\n    };\n  }\n> = {\n  count: (_, { count }) => count * 3,\n  instances: 2,\n  primitive: \"triangles\",\n  depth: { enable: false },\n  attributes: {\n    inst_id: (_, { ids }) => ({\n      buffer: ids,\n      stride: 4,\n      divisor: 1,\n    }),\n    vert_id: (_, { ids }) => ({\n      buffer: ids,\n      offset: 0,\n      stride: 4,\n      divisor: 0,\n    }),\n    ohlc: (_, { bar3x }) => ({\n      buffer: bar3x,\n      offset: 4,\n      stride: 6 * 4,\n    }),\n  },\n  uniforms: {\n    posColor: (_, { theme }) => theme.posColor,\n    negColor: (_, { theme }) => theme.negColor,\n    resolution: (ctx) => [ctx.viewportWidth, ctx.viewportHeight],\n    y_min_max: (_, { y_min_max }) => y_min_max,\n    x_zoom: (_, { x_zoom }) => x_zoom,\n    x_origin: (_, { x_origin }) => x_origin,\n  },\n  vert: `\n    precision mediump float;\n\n    uniform vec4 posColor;\n    uniform vec4 negColor;\n\n    uniform vec2 resolution;\n    uniform vec2 y_min_max;\n    uniform float x_zoom;\n    uniform float x_origin;\n\n    attribute float inst_id;\n    attribute float vert_id;\n    attribute vec4 ohlc;\n\n    varying vec4 color;\n\n    void main() {\n      color = ohlc[0] <= ohlc[3] ? posColor : negColor;\n\n      int vid = int(mod(vert_id, 3.0));\n      int iid = int(mod(inst_id, 2.0));\n\n      float y = (iid == 0 && vid != 1) || (iid == 1 && vid == 0)\n                ? ohlc[0] : ohlc[3];\n      y = floor(\n        resolution.y * (y - y_min_max[0]) / (y_min_max[1] - y_min_max[0])\n      );\n\n      float halved = x_zoom >= 3.0 ? floor((x_zoom - 2.0) / 3.0) + 1.0 : 0.0;\n      float x = floor(\n        (floor(vert_id / 3.0) - x_origin + 0.5) * x_zoom + 0.5\n      );\n      x += (iid == 0 && vid == 0) || (iid == 1 && vid != 2)\n           ? -halved - 1.0: +halved;\n\n      gl_Position = vec4(2.0 * vec2(x, y) / resolution - 1.0, 0., 1.);\n    }`,\n  frag: `\n    precision mediump float;\n    varying vec4 color;\n    void main() {\n      gl_FragColor = color;\n    }`,\n};\n","import { Regl } from \"regl\";\nimport { Wick } from \"./candle-wick\";\nimport { Body } from \"./candle-body\";\nimport { Border } from \"./candle-border\";\nimport { DataSource } from \"../../core/data-source\";\nimport { CandleThemeRGBA } from \"../../theme/build-theme\";\n\nexport function buildCandle(regl: Regl) {\n  const wick = regl(Wick);\n  const body = regl(Body);\n  const border = regl(Border);\n\n  return function (\n    source: DataSource,\n    view: {\n      x_zoom: number;\n      x_origin: number;\n      y_min_max: [number, number];\n    },\n    theme: CandleThemeRGBA,\n  ) {\n    const { bar2x, bar3x, ids } = source.buffers(regl);\n    wick(\n      { theme: theme.wick, bar2x, ids, count: source.length, ...view },\n    );\n    if (!theme.hollow) {\n      body({ theme: theme.body, bar3x, ids, count: source.length, ...view });\n    }\n    border({ theme: theme.border, bar2x, ids, count: source.length, ...view });\n  };\n}\n","import Regl from \"regl\";\n\nexport function buildRegl(\n  element: HTMLDivElement,\n  onResize?: (width: number, height: number) => void,\n) {\n  const pixelRatio =\n    (typeof window === \"undefined\" ? 1 : window.devicePixelRatio);\n  const canvas = document.createElement(\"canvas\");\n  Object.assign(canvas.style, {\n    border: 0,\n    margin: 0,\n    padding: 0,\n    top: 0,\n    left: 0,\n    display: \"block\",\n    imageRendering: \"pixelated\",\n  });\n  element.appendChild(canvas);\n\n  if (element === document.body) {\n    canvas.style.position = \"absolute\";\n    Object.assign(element.style, {\n      margin: 0,\n      padding: 0,\n    });\n  }\n\n  function resize() {\n    let w = window.innerWidth;\n    let h = window.innerHeight;\n    if (element !== document.body) {\n      let bounds = element.getBoundingClientRect();\n      w = bounds.width;\n      h = bounds.height;\n    }\n    canvas.width = pixelRatio * w;\n    canvas.height = pixelRatio * h;\n    Object.assign(canvas.style, {\n      width: w + \"px\",\n      height: h + \"px\",\n    });\n    onResize && onResize(pixelRatio * w, pixelRatio * h);\n  }\n\n  let resizeObserver: any;\n  // @ts-ignore\n  if (element !== document.body && typeof ResizeObserver === \"function\") {\n    // @ts-ignore\n    resizeObserver = new ResizeObserver(function () {\n      setTimeout(resize); // setTimeout to avoid flicker\n    });\n    resizeObserver.observe(element);\n  } else {\n    window.addEventListener(\"resize\", resize, false);\n  }\n\n  // TODO: clean up on destroy\n  function onDestroy() {\n    if (resizeObserver) {\n      resizeObserver.disconnect();\n    } else {\n      window.removeEventListener(\"resize\", resize);\n    }\n    element.removeChild(canvas);\n  }\n\n  resize();\n\n  const gl = canvas.getContext(\"webgl\", {\n    antialias: false,\n  }) as WebGLRenderingContext;\n\n  return Regl({\n    gl: gl,\n    extensions: [\n      \"ANGLE_instanced_arrays\",\n      \"OES_vertex_array_object\",\n    ],\n  });\n}\n","// convert any color to rgba in range [0, 1]\n// used to pass user defined colors to sharders.\nexport const to_rgba = (function () {\n  const cvs = document.createElement(\"canvas\");\n  cvs.height = 1;\n  cvs.width = 1;\n  const ctx = cvs.getContext(\"2d\") as CanvasRenderingContext2D;\n\n  const cache: { [key: string]: [number, number, number, number] } = {};\n\n  return function (\n    color: string,\n  ): [number, number, number, number] {\n    if (cache[color]) {\n      return cache[color];\n    }\n    if (!color) {\n      // return black for invalid input\n      return [0, 0, 0, 1];\n    }\n    ctx.fillStyle = color;\n    ctx.fillRect(0, 0, 1, 1);\n    const data = ctx.getImageData(0, 0, 1, 1).data as any;\n    return cache[color] = [...data].map((v) => v / 255) as [\n      number,\n      number,\n      number,\n      number,\n    ];\n  };\n})();\n","import { Theme } from \"./build-theme\";\n\nexport const LightTheme: Theme = {\n  candle: {\n    hollow: false,\n    border: {\n      posColor: \"#26a69a\",\n      negColor: \"#ef5350\",\n    },\n    body: {\n      posColor: \"#26a69a\",\n      negColor: \"#ef5350\",\n    },\n    wick: {\n      posColor: \"#26a69a\",\n      negColor: \"#ef5350\",\n    },\n  },\n};\n\nexport const DarkTheme: Theme = {\n  candle: {\n    hollow: false,\n    border: {\n      posColor: \"#26a69a\",\n      negColor: \"#ef5350\",\n    },\n    body: {\n      posColor: \"#26a69a\",\n      negColor: \"#ef5350\",\n    },\n    wick: {\n      posColor: \"#26a69a\",\n      negColor: \"#ef5350\",\n    },\n  },\n};\n","import { to_rgba } from \"./convert-color\";\nimport { LightTheme } from \"./default-themes\";\n\ntype CandleThemeImpl<CLR> = {\n  hollow: boolean;\n  wick: { posColor: CLR; negColor: CLR };\n  body: { posColor: CLR; negColor: CLR };\n  border: { posColor: CLR; negColor: CLR };\n};\n\nexport type ThemeRGBA = {\n  candle: CandleThemeImpl<[number, number, number, number]>;\n};\nexport type CandleThemeRGBA = CandleThemeImpl<\n  [number, number, number, number]\n>;\n\nexport type CandleTheme = CandleThemeImpl<string>;\nexport type Theme = { candle?: Partial<CandleTheme> };\nexport type ThemeAccessor = ReturnType<typeof buildTheme>;\n\nexport function buildTheme() {\n  let backup: Theme = {};\n  // @ts-ignore\n  let rgba: ThemeRGBA = {};\n\n  function setTheme(theme: Partial<Theme>) {\n    merge(backup, theme);\n    rgba = clone(backup);\n    rgba_colors(rgba);\n  }\n\n  // set the light theme by default\n  setTheme(LightTheme);\n\n  return {\n    getRGBA: () => rgba,\n    getTheme: () => backup,\n    setTheme,\n  };\n}\n\nfunction rgba_colors(obj: { [key: string]: any }) {\n  for (let k in obj) {\n    if (typeof obj[k] == \"object\" && obj[k] !== null) {\n      rgba_colors(obj[k]);\n    } else if (k.endsWith(\"Color\")) {\n      obj[k] = to_rgba(obj[k]);\n    }\n  }\n}\nfunction merge(\n  target: { [key: string]: any },\n  source: { [key: string]: any },\n) {\n  for (let k in source) {\n    if (\n      typeof source[k] == \"object\" && source[k]\n    ) {\n      target[k] = target[k] || {};\n      merge(target[k], source[k]);\n    } else {\n      target[k] = source[k];\n    }\n  }\n}\n\nconst clone = (obj: any) => JSON.parse(JSON.stringify(obj));\n","import { buildCandle } from \"./draw/candle/candle\";\nimport { Bar, buildDataSource } from \"./core/data-source\";\nimport { buildDataView } from \"./core/data-view\";\nimport { buildRegl } from \"./core/build-regl\";\nimport { buildTheme } from \"./theme/build-theme\";\nimport { trackUserInput } from \"./input/user-input\";\n\nexport type Chart = ReturnType<typeof buildChart>;\n\nexport function buildChart({ element }: {\n  element: HTMLDivElement;\n}) {\n  const source = buildDataSource();\n  const view = buildDataView(\n    300,\n    () => source.length,\n  );\n  const regl = buildRegl(\n    element,\n    (w, _) => view.setWidth(w),\n  );\n  const input = trackUserInput(view, element);\n  const theme = buildTheme();\n  const candle = buildCandle(regl);\n\n  regl.frame(() => {\n    const rgba = theme.getRGBA();\n    candle(source, {\n      x_origin: view.getOrigin(),\n      x_zoom: view.getZoom(),\n      y_min_max: [0, 10],\n    }, rgba.candle);\n  });\n\n  return {\n    source: source as Bar[],\n    view,\n    theme,\n  };\n}\n","import React, { useEffect, useRef } from \"react\";\nimport { render } from \"react-dom\";\nimport { buildChart } from '../../library/src/index';\nimport './index.css';\n\nfunction GChart() {\n  const ref = useRef();\n  useEffect(() => {\n    const element = ref.current as HTMLDivElement;\n    const chart = buildChart({ element });\n    // chart.theme.setTheme({ candle: { hollow: true } })\n\n    chart.source.push(\n\n      { epoch: 0, open: 3, high: 7, low: 3, close: 7, volume: 5 },\n      { epoch: 1, open: 7, high: 10, low: 2, close: 4, volume: 5 },\n      { epoch: 0, open: 3, high: 9, low: 1, close: 7, volume: 5 },\n      { epoch: 1, open: 7, high: 10, low: 2, close: 4, volume: 5 },\n      { epoch: 0, open: 3, high: 9, low: 1, close: 7, volume: 5 },\n      { epoch: 1, open: 7, high: 10, low: 2, close: 4, volume: 5 },\n      { epoch: 0, open: 3, high: 9, low: 1, close: 7, volume: 5 },\n      { epoch: 1, open: 7, high: 10, low: 2, close: 4, volume: 5 },\n    );\n\n    // @ts-ignore\n    window.chart = chart;\n  }, []);\n\n  return <div id='gchart' style={{\n    height: 'calc(100vh - 140px)'\n  }} ref={ref}></div>\n}\n\nfunction App() {\n  return <>\n    <h1> Hello World </h1>\n    <GChart />\n  </>\n}\n\nrender(<App />, document.getElementById(\"root\"));"]}